= Migrating to the Reach5Future SDK compatibility bridge

The *Reach5Future SDK* is a compatibility bridge for our iOS SDK customers who rely on BrightFutures for asynchronous operations and want to adopt Swift's native concurrency features one step at a time.
It ensures continued support for `Future`-based methods like `.onSuccess` and `.onFailure`, maintaining compatibility with existing codebases.

Our main iOS SDK is transitioning to `async throws` for future development, offering a modern, standardized approach to asynchronous programming.

The *Reach5Future SDK* allows a gradual migration, enabling customers to maintain their BrightFutures-based implementations while optionally integrating Swift concurrency in the same project.

== Installation Instructions

To use the *Reach5Future SDK*, integrate it into your project alongside or in place of the main {company} iOS SDK.
The compatibility bridge is provided as a separate module to ensure BrightFutures-based methods remain functional.

[source]
==== Installation

[tabs]
====
Cocoapods::
+
--

. Add this line to your `Podfile` file, replacing `x` with the latest version:
+
[source]
----
pod 'Reach5Future', '~> x'
----

. Then run:
+
[source, javascript]
----
pod install
----
--
Swift Package Manager::
+
--
Add the package dependency with XCode using this package URL:

[source]
----
https://github.com/ReachFive/reachfive-ios-future.git
----

Or directly add this to the dependencies in `Package.swift`

[source,swift,subs="attributes"]
----
dependencies: [
    .package(url: "https://github.com/ReachFive/reachfive-ios-future.git", .upToNextMajor(from: "x"))
]
----

--
====

== Handling compilation errors

When using the *Reach5Future SDK*, you may encounter compilation errors related to ambiguous return types in callbacks, particularly in nested `.map` and `.flatMap`.
To resolve this, explicitly specify the return type of the callback methods.

In this example, we try to register a new credential with a potentially stale token, and refresh it if necessary.

[source,swift]
----
AppDelegate.reachfive()
    .mfaStart(registering: credential, authToken: authToken)
    .recoverWith { error in
        guard case .AuthFailure(_, let apiError) = error, apiError?.errorMessageKey == "error.accessToken.freshness"
        else {
            return Future(error: error)
        }

        // Automatically refresh the token if it is stale
        return AppDelegate.reachfive()
            .refreshAccessToken(authToken: authToken).flatMap { (freshToken: AuthToken) -> Future<MfaStartRegistrationResponse, ReachFiveError> in <1>
                AppDelegate.storage.setToken(freshToken)
                return AppDelegate.reachfive().mfaStart(registering: credential, authToken: freshToken)
            }
    }
----
<1> Specify the return type explicitly to resolve the potential ambiguity in the callback.

== Explicit main thread binding

Unlike Swift's native concurrency, where thread management is explicit, BrightFutures often abstracts thread management.
However, when using the *Reach5Future SDK* for operations that update UI elements (e.g., displaying a profile in `goToProfile`), you may need to explicitly ensure these updates occur on the main thread using tools like @MainActor to avoid crashes or UI hangs.

.Example
[source,swift]
----
AppDelegate.reachfive().webviewLogin(WebviewLoginRequest(
    state: "zf3ifjfmdkj",
    nonce: "n-0S6_PzA3Ze",
    scope: ["openid", "profile", "email"],
    presentationContextProvider: self
))
.onSuccess { authToken in
    DispatchQueue.main.async {
        goToProfile(authToken) // Ensure UI update on main thread
    }
}
.onFailure { error in
    DispatchQueue.main.async {
        print("Error: \((error as? ReachFiveError)?.localizedDescription ?? error.localizedDescription)")
    }
}
----

== Mixed approaches

The *Reach5Future SDK* allows mixing BrightFutures' `Future`-based methods with Swift's `async throws` and `do-catch` in the same file, enabling a gradual migration to our main iOS SDK's concurrency model.

You can call `Future`-based methods from the *Reach5Future SDK* alongside `async throws` methods from the main SDK, wrapping `async` calls in a `Task` with `@MainActor` for synchronous contexts and UI updates.

.Example
[source,swift]
----
// Using Reach5Future SDK with BrightFutures
AppDelegate.reachfive().webviewLogin(WebviewLoginRequest(
    state: "zf3ifjfmdkj",
    nonce: "n-0S6_PzA3Ze",
    scope: ["openid", "profile", "email"],
    presentationContextProvider: self
))
.onSuccess { authToken in
    DispatchQueue.main.async {
        goToProfile(authToken) // Ensure UI update on main thread
    }
}
.onFailure { error in
    DispatchQueue.main.async {
        print("Error: \((error as? ReachFiveError)?.localizedDescription ?? error.localizedDescription)")
    }
}

// Using main ReachFive SDK with async throws and do-catch
do {
    let authToken = try await AppDelegate.reachfive().webviewLogin(
        WebviewLoginRequest(
            state: "zf3ifjfmdkj",
            nonce: "n-0S6_PzA3Ze",
            scope: ["openid", "profile", "email"],
            presentationContextProvider: self
        )
    )
    // Handle the successful authentication token
    Task { @MainActor in
        goToProfile(authToken) // Ensure UI update on main thread
    }
} catch {
    // Handle the error
    Task { @MainActor in
        print("Error: \(error.localizedDescription)")
        AppDelegate.storage.removeToken()
    }
}
----

[TBD by developer: Confirm whether specific methods in Reach5Future SDK differ from the main SDK or require unique handling when mixing with async/await.]
